(define (meta-eval eval-in-underlying-scheme apply-in-underlying-scheme)
  (define (show x)
    (display
     (parameterize ((print-graph #t)) (format "~s" (hide-func x))))
    (newline)
    x)
  (define (hide-func val)
    (cond ((compound-procedure? val) '<compound-procedure>)
	  ((primitive-procedure? val) '<primitive-procedure>)
	  (else val)))
  (define (show-env env)
    (display (format "------- ENVIRONMENT -------~%"))
    (for-each (lambda (var val)
		(parameterize ((print-graph #t))
		  (display (format "[var : ~s, val : ~s]~%"
				   var (hide-func val)))))
	      (caar env)
	      (cdar env)))
  (define (self-evaluating? exp)
    (cond ((number? exp) #t)
	  ((string? exp) #t)
	  ((eq? #f exp) #t)
	  ((eq? #t exp) #t)
	  ((eq? '*unassigned* exp) #t)
	  (else #f)))
  (define (variable? exp) (symbol? exp))
  (define (true? x)
    (not (eq? x #f)))
  (define (assignment? exp) ; (set! var val)
    (tagged-list? exp 'set!))
  (define (assignment-variable exp) (cadr exp))
  (define (assignment-value exp) (caddr exp))
  (define (definition? exp) ; (define ~~~)
    (tagged-list? exp 'define))
  (define (definition-variable exp)
    (if (symbol? (cadr exp))
	(cadr exp);(define x y)
	(caadr exp)));(define (x) (y))
  (define (definition-value exp)
    (if (symbol? (cadr exp))
	(caddr exp) ;(define x y) -> x
	(apply-in-underlying-scheme
	 make-lambda
	 (cdadr exp);(define (sq x) (* x x)) -> x
	 (cddr exp))));(define (sq x) (* x x)) -> (* x x)
  (define (nestdefs->let defs body)
    (define (iter varbind defs body)
      (if (null? defs)
	  (apply-in-underlying-scheme
	   make-let varbind body)
	  (let ((var (definition-variable (car defs)))
		(val (definition-value (car defs))))
	    (iter (cons
		   (list var '*unassigned*) varbind)
		  (cdr defs)
		  (cons
		   (list 'set! var val) body)))))
    (iter '() defs body))
  (define (scan-out-defines body)
    (define (iter defs body)
      (if (and (pair? (car body))
	       (definition? (car body)))
	  (iter (cons (car body) defs)
		(cdr body))
	  (if (null? defs)
	      body
	      (list (nestdefs->let defs body)))))
    (iter '() body))
  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
      (show (eval (definition-value exp) env))
      env)
    'ok)
  (define (lambda? exp);(lambda (x) y)
    (tagged-list? exp 'lambda))
  (define (lambda-parameters exp) (cadr exp))
  (define (lambda-body exp) (cddr exp))
  (define (if? exp) ;(if pred conseq alt)
    (tagged-list? exp 'if))
  (define (if-predicate exp) (cadr exp))
  (define (if-consequent exp) (caddr exp))
  (define (if-alternative exp)
    (if (not (null? (cdddr exp)))
	(cadddr exp)
	'false))
  (define (make-if pred conseq alt)
    (list 'if pred conseq alt))
  (define (begin? exp) (tagged-list? exp 'begin))
  (define (begin-actions exp) (cdr exp))
  (define (last-exp? seq) (null? (cdr seq)))
  (define (first-exp seq) (car seq))
  (define (rest-exps seq) (cdr seq))
  (define (sequence->exp seq)
    (cond ((null? seq) seq)
	  ((last-exp? seq) (first-exp seq))
	  (else (make-begin seq))))
  (define (make-begin seq) (cons 'begin seq))
  (define (application? exp) (pair? exp))
  (define (operator exp) (car exp))
  (define (operands exp) (cdr exp))
  (define (no-operands? ops) (null? ops))
  (define (first-operand ops) (car ops))
  (define (rest-operands ops) (cdr ops))
  (define (cond? exp) (tagged-list? exp 'cond))
  (define (cond-clauses exp) (cdr exp))
  (define (cond-else-clause? clause)
    (eq? (cond-predicate clause) 'else))
  (define (cond-predicate clause) (car clause))
  (define (cond-actions clause) (cdr clause))
  (define (cond->if exp)
    (expand-clauses (cond-clauses exp)))
  (define (arrowed? clause) (eq? '=> (cadr clause)))
  (define (arrowed-action clause) (caddr clause))
  (define (expand-clauses clauses)
    (if (null? clauses)
	'false
	(let ((first (car clauses))
	      (rest (cdr clauses)))
	  (if (cond-else-clause? first)
	      (if (null? rest)
		  (sequence->exp (cond-actions first))
		  (errorf 'COND->IF "else clause isn`t last"))
	      (if (arrowed? first)
		  (make-if (cond-predicate first)
			   (list (arrowed-action first) (cond-predicate first))
			   (expand-clauses rest))
		  (make-if (cond-predicate first)
			   (sequence->exp (cond-actions first))
			   (expand-clauses rest)))))))
  (define (quoted? exp) ;(quote something)
    (tagged-list? exp 'quote))
  (define (text-of-quotation exp) (cadr exp))
  (define (tagged-list? exp tag)
    (if (pair? exp)
	(eq? (car exp) tag)
	#f))
					;could use maps
  (define (list-of-values exps env);_arguments_ _eval
    (if (no-operands? exps)
	'()
	(cons (eval (first-operand exps) env)
	      (list-of-values (rest-operands exps) env))))
  (define (eval-if exp env);_conditionals_
    (if (true? (eval (if-predicate exp) env))
	(eval (if-consequent exp) env)
	(eval (if-alternative exp) env)))
  (define (eval-assignment exp env)
    (set-variable-value! (assignment-variable exp)
			 (eval (assignment-value exp) env)
			 env)
    'ok)
  (define (eval-sequence exps env);_sequences_ _eval
    (cond ((last-exp? exps) (eval (first-exp exps) env))
	  (else (eval (first-exp exps) env)
		(eval-sequence (rest-exps exps) env))))
  (define (or? exp) (tagged-list? exp 'or))
  (define (and? exp) (tagged-list? exp 'and))
  (define (tests exp) (cdr exp))
  (define (eval-or lst env)
    (cond ((null? lst) 'false)
	  ((true? (eval (car lst) env)) 'true)
	  (else (eval-or (cdr lst) env))))
  (define (eval-and lst env)
    (cond ((null? lst) 'true)
	  ((not (true? (eval (car lst) env))) 'false)
	  (else (eval-and (cdr lst) env))))
  (define (let? exp) (tagged-list? exp 'let))
  (define (make-lambda varlist . expressions)
    (append (list 'lambda varlist)
	    expressions))
  (define (let-binds exp) (cadr exp))
  (define (let-body-lst exp) (cddr exp))
  (define (extract-vars exp) (map car exp))
  (define (extract-vals exp) (map cadr exp))
  (define (make-let binds . body-lst)
    (cons 
     (apply-in-underlying-scheme
      make-lambda (extract-vars binds) body-lst)
     (extract-vals binds)))
  (define (casing-env . exps)
    (list (apply-in-underlying-scheme
	   make-lambda '() exps)))
					;mad
  (define (make-definition name exp)
    (list 'define name exp))
  (define (named-let? exp) (not (pair? (cadr exp))))
  (define (name-of-let exp) (cadr exp))
  (define (named-let-binds exp) (caddr exp))
  (define (named-let-body-list exp) (cdddr exp))
  (define (make-named-let name binds . body-list)
    (casing-env
     (make-definition name
		      (apply-in-underlying-scheme
		       make-lambda (extract-vars binds)
		       body-list))
     (cons name (extract-vals binds))))
  (define (let->combination exp)
    (if (named-let? exp)
	(apply-in-underlying-scheme
	 make-named-let
	 (name-of-let exp)
	 (named-let-binds exp) (named-let-body-list exp))
	(apply-in-underlying-scheme
	 make-let (let-binds exp) (let-body-lst exp))))
  (define (let*? exp) (tagged-list? exp 'let*))
  (define (let*->nested-lets exp)
    (define (rec binds body-lst)
      (if (null? (cdr  binds))
	  (apply-in-underlying-scheme
	   make-let (list (car binds)) body-lst)
	  (make-let (list (car binds)) (rec (cdr binds) body-lst))))
    (rec (let-binds exp) (let-body-lst exp)))
  (define (letrec? exp) (tagged-list? exp 'letrec))
  (define (letrec->let-sets exp)
    (define (re-bind bind body)
      (append
       (map (lambda (b) (cons 'set! b)) bind)
       body))
    (define (bind-nothing bind)
      (map (lambda (b) (list (car b) '*unassigned*)) bind))
    (let ((bind (let-binds exp))
	  (bodyl (let-body-lst exp)))
      (apply-in-underlying-scheme
       make-let
       (bind-nothing bind)
       (re-bind bind bodyl))))
  (define (do? env) (tagged-list? env 'do))
  (define (do-vars binds) (map car binds))
  (define (do-init binds) (map cadr binds))
  (define (do-iter binds) (map caddr binds))
  (define (make-do binds test . exps)
    (let ((temp-name (gensym)))
      (casing-env
       (make-definition
	temp-name
	(make-lambda
	 (do-vars binds)
	 (list 'cond
	       test
	       (append '(else)
		       exps
		       (list (cons temp-name (do-iter binds)))))))
       (cons temp-name (do-init binds)))))
  (define (do->combination exp)
    (apply-in-underlying-scheme make-do (cdr exp)))
  (define (make-procedure parameters body env)
    (list 'procedure parameters (scan-out-defines body) env))
  (define (compound-procedure? p)
    (tagged-list? p 'procedure))
  (define (procedure-parameters p) (cadr p))
  (define (procedure-body p) (caddr p))
  (define (procedure-environment p) (cadddr p))
  (define (enclosing-environment env) (cdr env))
  (define (first-frame env) (car env))
  (define the-empty-environment '())
  (define (make-frame vars vals)
    (cons vars vals))
  (define (frame-variables frame) (car frame))
  (define (frame-values frame) (cdr frame))
  (define (add-binding-to-frame! var val frame)
    (set-car! frame (cons var (car frame)))
    (set-cdr! frame (cons val (cdr frame))))
  (define (extend-environment vars vals base-env)
    (if (= (length vars) (length vals))
	(cons (make-frame vars vals) base-env)
	(if (< (legth vars) (length vals))
	    (errorf 'extend-environment "Too many args-~s/~s" vars vals)
	    (errorf 'extend-environment "Too few args-~s/~s" vars vals))))
  (define (scan-frame var vars vals)
    (cond ((null? vars) #f)
	  ((eq? var (car vars)) vals)
	  (else (scan-frame var (cdr vars) (cdr vals)))))
  (define (env-loop var env)
    (if (eq? env the-empty-environment)
	#f
	(let ((frame (first-frame env)))
	  (let ((scanned (scan-frame
			  var
			  (frame-variables frame)
			  (frame-values frame))))
	    (if scanned
		scanned
		(env-loop var (enclosing-environment env)))))))
  (define (lookup-variable-value var env)
    (let ((scan-val (env-loop var env)))
      (if (and scan-val (not (eq? (car scan-val) '*unassigned*)))
	  (car scan-val)
	  (errorf 'lookup-variable-value "Unbound variable : ~s" var))))
  (define (set-variable-value! var val env)
    (let ((scan-val (env-loop var env)))
      (if scan-val
	  (set-car! scan-val val)
	  (errorf 'set-variable-value! "Unbound variable ~s" var))))
  (define (define-variable! var val env)
    (let ((frame (first-frame env)))
      (let ((scan-val (scan-frame
		       var
		       (frame-variables frame)
		       (frame-values frame))))
	(if scan-val
	    (set-car! scan-val val)
	    (add-binding-to-frame! var val frame)))))
  (define (scan-frame-full var vars vals)
    (cond ((null? vars) #f)
	  ((eq? var (car vars)) 'found)
	  (else
	   (let ((pick (scan-frame-full var (cdr vars) (cdr vals))))
	     (if (eq? pick 'found) (cons vars vals) pick)))))
  (define (env-loop-full var env)
    (if (eq? env the-empty-environment)
	#f
	(let ((frame (first-frame env)))
	  (let ((scanned (scan-frame-full
			  var
			  (frame-variables frame)
			  (frame-values frame))))
	    (cond
	     ((eq? scanned 'found) (cons 'found env))
	     (scanned scanned)
	     (else (env-loop-full var (enclosing-environment env))))))))
  (define (make-unbound! var env)
    (let ((scanned (env-loop-full var env)))
      (cond ((not scanned) 'false)
	    ((eq? (car scanned) 'found)
	     (let ((frame (first-frame (cdr scanned)))
		   (target-env (cdr scanned)))
	       (set-car! target-env
			 (make-frame
			  (cdr (frame-variables frame))
			  (cdr (frame-values frame))))
	       'true))
	    (scanned
	     (let ((sc-var (car scanned))
		   (sc-val (cdr scanned)))
	       (set-cdr! sc-var (cddr sc-var))
	       (set-cdr! sc-val (cddr sc-val))
	       'true))
	    (else 'false))))
  (define (unbinder? exp)
    (tagged-list? exp 'unbind!))
  (define (unbind exp env)
    (let ((removed-var (cadr exp)))
      (make-unbound! removed-var env)))
  (define (eval exp env);_eval_
    (show-env env)
    (cond
     ((self-evaluating? exp) exp)
     ((variable? exp) (lookup-variable-value exp env))
     ((quoted? exp) (text-of-quotation exp))
     ((assignment? exp) (eval-assignment exp env))
     ((definition? exp) (eval-definition exp env))
     ((if? exp) (eval-if exp env))
     ((lambda? exp)
      (make-procedure (lambda-parameters exp)
		      (lambda-body exp)
		      env))
     ((let? exp) (eval (let->combination exp) env))
     ((let*? exp) (eval (let*->nested-lets exp) env))
     ((letrec? exp) (eval (letrec->let-sets exp) env))
     ((unbinder? exp) (unbind exp env))
     ((do? exp) (eval (do->combination exp) env))
     ((begin? exp)
      (eval-sequence (begin-actions exp) env))
     ((cond? exp) (eval (cond->if exp) env))
     ((and? exp) (eval-and (tests exp) env))
     ((or? exp) (eval-or (tests exp) env))
     ((application? exp)
      (apply (eval (operator exp) env)
	     (list-of-values (operands exp) env)))
     (else (errorf 'EVAL "Unknown Expression Type:~s" exp))))
  (define (apply procedure arguments);_apply_
    (cond ((primitive-procedure? procedure)
	   (apply-primitive-procedure procedure arguments))
	  ((compound-procedure? procedure)
	   (eval-sequence
	    (procedure-body procedure)
	    (extend-environment
	     (procedure-parameters procedure)
	     arguments
	     (procedure-environment procedure))))
	  (else (errorf 'APPLY "Unknown Procedure Type:~s" procedure))))
  (define primitive-procedures
    (list (list 'car car)
	  (list 'cdr cdr)
	  (list 'cons cons)
	  (list 'null? null?)
	  (list '+ +)
	  (list '- -)
	  (list '* *)
	  (list '/ /)
	  (list '= =)
	  (list 'display display)
	  (list 'newline newline)))
  (define (primitive-procedure-names)
    (map car
	 primitive-procedures))
  (define (primitive-procedure-objects)
    (map (lambda (proc) (list 'primitive (cadr proc)))
	 primitive-procedures))
  (define (setup-environment)
    (let ((initial-env
	   (extend-environment (primitive-procedure-names)
			       (primitive-procedure-objects)
			       the-empty-environment)))
      (define-variable! 'true #t initial-env)
      (define-variable! 'false #f initial-env)
      (define-variable! 'nil '() initial-env)
      initial-env))
  (define the-global-environment (setup-environment))
  (define (primitive-procedure? proc)
    (tagged-list? proc 'primitive))
  (define (primitive-implementation proc) (cadr proc))
  (define (apply-primitive-procedure proc args)
    (apply-in-underlying-scheme
     (primitive-implementation proc) args))
  (define input-prompt ";;; M-Eval input:")
  (define output-prompt ";;; M-Eval output:")
  (define (driver-loop)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (let ((output (eval input the-global-environment)))
	(announce-output output-prompt)
	(user-print output)))
    (driver-loop))
  (define (prompt-for-input string)
    (newline)
    (newline)
    (display string)
    (newline))
  (define (announce-output string)
    (newline)
    (display string)
    (newline))
  (define (user-print object)
    (cond ((compound-procedure? object)
	   (display (list 'compound-procedure
			  (procedure-parameters object)
			  (procedure-body object)
			  '<procedure-env>)))
	  (else (display object))))
  (driver-loop))
(define (m-eval) (meta-eval eval apply))

;(meta-eval eval apply)
(do ((n 1 (+ n 1)))
    ((= n 10) #f)
  (let fib
      ((count n)
       (prev 0)
       (cur 1))
    (if (= count 0)
	(begin (display prev) (newline) prev)
	(fib (- count 1) cur (+ prev cur)))))
(define (f x) ;4.16
  (define (even? n)
    (if (= n 0)
	true
	(odd? (- n 1))))
  (define (odd? n)
    (if (= n 0)
	false
	(even? (- n 1))))
  (even? x))
(define (f x)
  (letrec ((even?
	    (lambda (n)
	      (if (= n 0)
		  true
		  (odd? (- n 1)))))
	   (odd?
	    (lambda (n)
	      (if (= n 0)
		  false
		  (even? (- n 1))))))
    (even? x)))
