(define (meta-eval eval-in-underlying-scheme apply-in-underlying-scheme)
  (define (self-evaluating? exp)
    (cond ((number? exp) #t)
	  ((string? exp) #t)
	  ((eq? #f exp) #t)
	  ((eq? #t exp) #t)
	  (else #f)))
  (define (variable? exp) (symbol? exp))
  (define (true? x)
    (not (eq? x #f)))
  (define (assignment? exp) ; (set! var val)
    (tagged-list? exp 'set!))
  (define (assignment-variable exp) (cadr exp))
  (define (assignment-value exp) (caddr exp))
  (define (definition? exp) ; (define ~~~)
    (tagged-list? exp 'define))
  (define (definition-variable exp)
    (if (symbol? (cadr exp))
	(cadr exp);(define x y)
	(caadr exp)));(define (x) (y))
  (define (definition-value exp)
    (if (symbol? (cadr exp))
	(caddr exp) ;(define x y) -> x
	(apply-in-underlying-scheme
	 make-lambda (cdadr exp);(define (sq x) (* x x)) -> x
	 (cddr exp))));(define (sq x) (* x x)) -> (* x x)
  (define (lambda? exp);(lambda (x) y)
    (tagged-list? exp 'lambda))
  (define (lambda-parameters exp) (cadr exp))
  (define (lambda-body exp) (cddr exp))
  (define (if? exp) ;(if pred conseq alt)
    (tagged-list? exp 'if))
  (define (if-predicate exp) (cadr exp))
  (define (if-consequent exp) (caddr exp))
  (define (if-alternative exp)
    (if (not (null? (cdddr exp)))
	(cadddr exp)
	'false))
  (define (make-if pred conseq alt)
    (list 'if pred conseq alt))
  (define (begin? exp) (tagged-list? exp 'begin))
  (define (begin-actions exp) (cdr exp))
  (define (last-exp? seq) (null? (cdr seq)))
  (define (first-exp seq) (car seq))
  (define (rest-exps seq) (cdr seq))
  (define (sequence->exp seq)
    (cond ((null? seq) seq)
	  ((last-exp? seq) (first-exp seq))
	  (else (make-begin seq))))
  (define (make-begin seq) (cons 'begin seq))
  (define (application? exp) (pair? exp))
  (define (operator exp) (car exp))
  (define (operands exp) (cdr exp))
  (define (no-operands? ops) (null? ops))
  (define (first-operand ops) (car ops))
  (define (rest-operands ops) (cdr ops))
  (define (cond? exp) (tagged-list? exp 'cond))
  (define (cond-clauses exp) (cdr exp))
  (define (cond-else-clause? clause)
    (eq? (cond-predicate clause) 'else))
  (define (cond-predicate clause) (car clause))
  (define (cond-actions clause) (cdr clause))
  (define (cond->if exp)
    (expand-clauses (cond-clauses exp)))
  (define (arrowed? clause) (eq? '=> (cadr clause)))
  (define (arrowed-action clause) (caddr clause))
  (define (expand-clauses clauses)
    (if (null? clauses)
	'false
	(let ((first (car clauses))
	      (rest (cdr clauses)))
	  (if (cond-else-clause? first)
	      (if (null? rest)
		  (sequence->exp (cond-actions first))
		  (errorf 'COND->IF "else clause isn`t last"))
	      (if (arrowed? first)
		  (make-if (cond-predicate first)
			   (list (arrowed-action first) (cond-predicate first))
			   (expand-clauses rest))
		  (make-if (cond-predicate first)
			   (sequence->exp (cond-actions first))
			   (expand-clauses rest)))))))
  (define (quoted? exp) ;(quote something)
    (tagged-list? exp 'quote))
  (define (text-of-quotation exp) (cadr exp))
  (define (tagged-list? exp tag)
    (if (pair? exp)
	(eq? (car exp) tag)
	#f))
					;could use maps
  (define (list-of-values exps env);_arguments_ _eval
    (if (no-operands? exps)
	'()
	(cons (eval (first-operand exps) env)
	      (list-of-values (rest-operands exps) env))))
  (define (eval-if exp env);_conditionals_
    (if (true? (eval (if-predicate exp) env))
	(eval (if-consequent exp) env)
	(eval (if-alternative exp) env)))
  (define (eval-assignment exp env)
    (set-variable-value! (assignment-variable exp)
			 (eval (assignment-value exp) env)
			 env)
    'ok)
  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
      (eval (definition-value exp) env)
      env)
    'ok)
  (define (eval-sequence exps env);_sequences_ _eval
    (cond ((last-exp? exps) (eval (first-exp exps) env))
	  (else (eval (first-exp exps) env)
		(eval-sequence (rest-exps exps) env))))
  (define (or? exp) (tagged-list? exp 'or))
  (define (and? exp) (tagged-list? exp 'and))
  (define (tests exp) (cdr exp))
  (define (eval-or lst env)
    (cond ((null? lst) 'false)
	  ((true? (eval (car lst) env)) 'true)
	  (else (eval-or (cdr lst) env))))
  (define (eval-and lst env)
    (cond ((null? lst) 'true)
	  ((not (true? (eval (car lst) env))) 'false)
	  (else (eval-and (cdr lst) env))))
  (define (let? exp) (tagged-list? exp 'let))
  (define (make-lambda varlist . expressions)
    (append (list 'lambda varlist)
	    expressions))
  (define (let-binds exp) (cadr exp))
  (define (let-body-lst exp) (cddr exp))
  (define (extract-vars exp) (map car exp))
  (define (extract-vals exp) (map cadr exp))
  (define (make-let binds . body-lst)
    (cons 
     (apply-in-underlying-scheme
      make-lambda (extract-vars binds) body-lst)
     (extract-vals binds)))
  (define (casing-env . exps)
    (list (apply-in-underlying-scheme
	   make-lambda '() exps)))
					;mad
  (define (make-definition name exp)
    (list 'define name exp))
  (define (named-let? exp) (not (pair? (cadr exp))))
  (define (name-of-let exp) (cadr exp))
  (define (named-let-binds exp) (caddr exp))
  (define (named-let-body-list exp) (cdddr exp))
  (define (make-named-let name binds . body-list)
    (casing-env
     (make-definition name
		      (apply-in-underlying-scheme
		       make-lambda (extract-vars binds)
		       body-list))
     (cons name (extract-vals binds))))
  (define (let->combination exp)
    (if (named-let? exp)
	(apply-in-underlying-scheme
	 make-named-let
	 (name-of-let exp)
	 (named-let-binds exp) (named-let-body-list exp))
	(apply-in-underlying-scheme
	 make-let (let-binds exp) (let-body-lst exp))))
  (define (let*? exp) (tagged-list? exp 'let*))
  (define (let*->nested-lets exp)
    (define (rec binds body-lst)
      (if (null? (cdr  binds))
	  (apply-in-underlying-scheme
	   make-let (list (car binds)) body-lst)
	  (make-let (list (car binds)) (rec (cdr binds) body-lst))))
    (rec (let-binds exp) (let-body-lst exp)))
  (define (do? env) (tagged-list? env 'do))
  (define (do-vars binds) (map car binds))
  (define (do-init binds) (map cadr binds))
  (define (do-iter binds) (map caddr binds))
  (define (make-do binds test . exps)
    (let ((temp-name (gensym)))
      (casing-env
       (make-definition
	temp-name
	(make-lambda
	 (do-vars binds)
	 (list 'cond
	       test
	       (append '(else)
		       exps
		       (list (cons temp-name (do-iter binds)))))))
       (cons temp-name (do-init binds)))))
  (define (do->combination exp)
    (apply-in-underlying-scheme make-do (cdr exp)))
  (define (make-procedure parameters body env)
    (list 'procedure parameters body env))
  (define (compound-procedure? p)
    (tagged-list? p 'procedure))
  (define (procedure-parameters p) (cadr p))
  (define (procedure-body p) (caddr p))
  (define (procedure-environment p) (cadddr p))
  (define (enclosing-environment env) (cdr env))
  (define (first-frame env) (car env))
  (define the-empty-environment '())
  (define (make-frame vars vals)
    (cons vars vals))
  (define (frame-variables frame) (car frame))
  (define (frame-values frame) (cdr frame))
  (define (add-binding-to-frame! var val frame)
    (set-car! frame (cons var (car frame)))
    (set-cdr! frame (cons val (cdr frame))))
  (define (extend-environment vars vals base-env)
    (if (= (length vars) (length vals))
	(cons (make-frame vars vals) base-env)
	(if (< (legth vars) (length vals))
	    (errorf 'extend-environment "Too many args-~s/~s" vars vals)
	    (errorf 'extend-environment "Too few args-~s/~s" vars vals))))
  (define (scan-frame var vars vals)
    (cond ((null? vars) #f)
	  ((eq? var (car vars)) vals)
	  (else (scan-frame var (cdr vars) (cdr vals)))))
  (define (env-loop var env)
    (if (eq? env the-empty-environment)
	#f
	(let ((frame (first-frame env)))
	  (let ((scanned (scan-frame
			  var
			  (frame-variables frame)
			  (frame-values frame))))
	    (if scanned
		scanned
		(env-loop var (enclosing-environment env)))))))
  (define (lookup-variable-value var env)
    (let ((scan-val (env-loop var env)))
      (if scan-val
	  (car scan-val)
	  (errorf 'lookup-variable-value "Unbound variable : ~s" var))))
  (define (set-variable-value! var val env)
    (let ((scan-val (env-loop var env)))
      (if scan-val
	  (set-car! scan-val val)
	  (errorf 'set-variable-value! "Unbound variable ~s" var))))
  (define (define-variable! var val env)
    (let ((frame (first-frame env)))
      (let ((scan-val (scan-frame
		       var
		       (frame-variables frame)
		       (frame-values frame))))
	(if scan-val
	    (set-car! scan-val val)
	    (add-binding-to-frame! var val frame)))))
  (define (scan-frame-full var vars vals)
    (cond ((null? vars) #f)
	  ((eq? var (car vars)) 'found)
	  (else
	   (let ((pick (scan-frame-full var (cdr vars) (cdr vals))))
	     (if (eq? pick 'found) (cons vars vals) pick)))))
  (define (env-loop-full var env)
    (if (eq? env the-empty-environment)
	#f
	(let ((frame (first-frame env)))
	  (let ((scanned (scan-frame-full
			  var
			  (frame-variables frame)
			  (frame-values frame))))
	    (cond
	     ((eq? scanned 'found) (cons 'found env))
	     (scanned scanned)
	     (else (env-loop-full var (enclosing-environment env))))))))
  (define (make-unbound! var env)
    (let ((scanned (env-loop-full var env)))
      (cond ((not scanned) 'false)
	    ((eq? (car scanned) 'found)
	     (let ((frame (first-frame (cdr scanned)))
		   (target-env (cdr scanned)))
	       (set-car! target-env
			 (make-frame
			  (cdr (frame-variables frame))
			  (cdr (frame-values frame))))
	       'true))
	    (scanned
	     (let ((sc-var (car scanned))
		   (sc-val (cdr scanned)))
	       (set-cdr! sc-var (cddr sc-var))
	       (set-cdr! sc-val (cddr sc-val))
	       'true))
	    (else 'false))))
  (define (unbinder? exp)
    (tagged-list? exp 'unbind!))
  (define (unbind exp env)
    (let ((removed-var (cadr exp)))
      (make-unbound! removed-var env)))
  (define (eval exp env);_eval_
    (cond
     ((self-evaluating? exp) exp)
     ((variable? exp) (lookup-variable-value exp env))
     ((quoted? exp) (text-of-quotation exp))
     ((assignment? exp) (eval-assignment exp env))
     ((definition? exp) (eval-definition exp env))
     ((if? exp) (eval-if exp env))
     ((lambda? exp)
      (make-procedure (lambda-parameters exp)
		      (lambda-body exp)
		      env))
     ((let? exp) (eval (let->combination exp) env))
     ((let*? exp) (eval (let*->nested-lets exp) env))
     ((unbinder? exp) (unbind exp env))
     ((do? exp) (eval (do->combination exp) env))
     ((begin? exp)
      (eval-sequence (begin-actions exp) env))
     ((cond? exp) (eval (cond->if exp) env))
     ((and? exp) (eval-and (tests exp) env))
     ((or? exp) (eval-or (tests exp) env))
     ((application? exp)
      (apply (eval (operator exp) env)
	     (list-of-values (operands exp) env)))
     (else (errorf 'EVAL "Unknown Expression Type"))))
  (define (apply procedure arguments);_apply_
    (cond ((primitive-procedure? procedure)
	   (apply-primitive-procedure procedure arguments))
	  ((compound-procedure? procedure)
	   (eval-sequence
	    (procedure-body procedure)
	    (extend-environment
	     (procedure-parameters procedure)
	     arguments
	     (procedure-environment procedure))))
	  (else (errorf 'APPLY "Unknown Procedure Type"))))
  (define primitive-procedures
    (list (list 'car car)
	  (list 'cdr cdr)
	  (list 'cons cons)
	  (list 'null? null?)
	  (list '+ +)
	  (list '- -)
	  (list '* *)
	  (list '/ /)
	  (list '= =)
	  (list 'display display)
	  (list 'newline newline)))
  (define (primitive-procedure-names)
    (map car
	 primitive-procedures))
  (define (primitive-procedure-objects)
    (map (lambda (proc) (list 'primitive (cadr proc)))
	 primitive-procedures))
  (define (setup-environment)
    (let ((initial-env
	   (extend-environment (primitive-procedure-names)
			       (primitive-procedure-objects)
			       the-empty-environment)))
      (define-variable! 'true #t initial-env)
      (define-variable! 'false #f initial-env)
      (define-variable! 'nil '() initial-env)
      initial-env))
  (define the-global-environment (setup-environment))
  (define (primitive-procedure? proc)
    (tagged-list? proc 'primitive))
  (define (primitive-implementation proc) (cadr proc))
  (define (apply-primitive-procedure proc args)
    (apply-in-underlying-scheme
     (primitive-implementation proc) args))
  (define input-prompt ";;; M-Eval input:")
  (define output-prompt ";;; M-Eval output:")
  (define (driver-loop)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (let ((output (eval input the-global-environment)))
	(announce-output output-prompt)
	(user-print output)))
    (driver-loop))
  (define (prompt-for-input string)
    (newline)
    (newline)
    (display string)
    (newline))
  (define (announce-output string)
    (newline)
    (display string)
    (newline))
  (define (user-print object)
    (cond ((compound-procedure? object)
	   (display (list 'compound-procedure
			  (procedure-parameters object)
			  (procedure-body object)
			  '<procedure-env>)))
	  (else (display object))))
  (driver-loop))
(define (m-eval) (meta-eval eval apply))

;(meta-eval eval apply)
(do ((n 1 (+ n 1)))
    ((= n 10) #f)
  (let fib
      ((count n)
       (prev 0)
       (cur 1))
    (if (= count 0)
	(begin (display prev) (newline) prev)
	(fib (- count 1) cur (+ prev cur)))))












4.1
(define (list-of-values exps env);Left
  (if (no-operands? exps)
      '()
      (let ((head (eval (first-operand exps) env)))
	(cons head
	      (list-of-values (rest-operands exps) env)))))
(define (list-of-values exps env);Right
  (if (no-operands? exps)
      '()
      (let ((tail (list-of-values (rest-operands exps) env)))
	(cons (eval (first-operand exps) env)
	      tail))))

4.2
;a : does not detect special forms anymore
;b
(define (application? exp) (tagged-list? exp 'call))
(define (app-exp exp) (cdr exp))
(define (eval exp env)
  (cond
   ((self-evaluating? exp) exp)
   ((variable? exp) (lookup-variable-value exp env))
   ((application? exp)
    (apply (eval (operator (app-exp exp)) env)
	   (list-of-values (operands (app-exp exp)) env)))
   ((quoted? exp) (text-of-quotation exp))
   ((assigment? exp) (eval-assignment exp env))
   ((definition? exp) (eval-definition exp env))
   ((if? exp) (eval-if exp env))
   ((lambda? exp)
    (make-procedure (lambda-parameters exp)
		    (lambda-body exp)
		    env))
   ((begin? exp)
    (eval-sequence (begin-actions exp) env))
   ((cond? exp) (eval (cond->if exp) env))
   (else (errorf 'EVAL "Unknown Expression Type"))))

4.3
;using 3.25
(define *ev-table* (make-table eq?))
(define (put op type item)
  ((*ev-table* 'insert-proc!) (list op type) item))
(define (get op type)
  ((*ev-table* 'lookup-proc) (list op type)))

(define (self-evaluating? exp)
  (cond ((number? exp) #t)
	((string? exp) #t)
	(else #f)))
(define (variable? exp) (symbol? exp))

(define (add-assignment)
  (define (assignment-variable exp) (cadr exp))
  (define (assignment-value exp) (caddr exp))
  (define (eval-assignment exp env)
    (set-variable-value! (assignment-variable exp)
			 (eval (assignment-value exp) env)
			 env)
    'ok)
  (put 'eval 'set! eval-assignment))
(define (add-definition)
  (define (definition-variable exp)
    (if (symbol? (cadr exp))
	(cadr exp);(define x y)
	(caadr exp)));(define (x) (y))
  (define (defintion-value exp)
    (if (symbol? (cadr exp))
	(caddr exp) ;(define x y) -> x
	(make-lambda (cdadr exp);(define (sq x) (* x x)) -> (x)
		     (cddr exp))))
  (define (eval-definition exp env)
    (define-variable! (definition-variable exp)
      (eval (definition-value exp) env)
      env)
    'ok)
  (put 'eval 'define eval-definition))
(define (add-lambda)
  (define (lambda-parameters exp) (cadr exp))
  (define (lambda-body exp) (cddr exp))
  (define (make-lambda parameters body)
    (cons 'lambda parameters body))
  (define (eval-lambda exp env)
    (make-procedure (lambda-parameters exp)
		    (lambda-body exp)
		    env))
  (put 'eval 'lambda eval-lambda))

(define (add-if)
  (define (if-predicate exp) (cadr exp))
  (define (if-consequent exp) (caddr exp))
  (define (if-alternative exp)
    (if (not (null? (cdddr exp)))
	(caddr exp)
	'false))
  (define (make-if pred conseq alt)
    (list 'if pred conseq alt))
  (define (eval-if exp env)
    (if (true? (eval (if-predicate exp) env))
	(eval (if-consequent exp) env)
	(eval (if-alternative exp) env)))
  (put 'eval 'if eval-if))

;etc etc

(define (eval exp env);_eval_
  (cond
   ((self-evaluating? exp) exp)
   ((variable? exp) (lookup-variable-value exp env))
   ((get 'eval (tag exp))
    ((get 'eval (tag exp)) exp env))
   ((application? exp)
    (apply (eval (operator exp) env)
	   (list-of-values (operands exp) env)))
   (else (errorf 'EVAL "Unknown Expression Type"))))

4.4
(define (or? exp) (tagged-list? exp 'or))
(define (and? exp) (tagged-list? exp 'and))
(define (tests exp) (cdr exp))
(define (eval-or lst env)
  (cond ((null? lst) 'false)
	((true? (eval (car lst) env)) 'true)
	(else (eval-or (cdr lst) env))))
(define (eval-and lst env)
  (cond ((null? lst) 'true)
	((not (true? (eval (car lst) env))) 'false)
	(else (eval-and (cdr lst) env))))


(define (eval exp env);_eval_
  (cond
   ((self-evaluating? exp) exp)
   ((variable? exp) (lookup-variable-value exp env))
   ((quoted? exp) (text-of-quotation exp))
   ((assigment? exp) (eval-assignment exp env))
   ((definition? exp) (eval-definition exp env))
   ((if? exp) (eval-if exp env))
   ((lambda? exp)
    (make-procedure (lambda-parameters exp)
		    (lambda-body exp)
		    env))
   ((begin? exp)
    (eval-sequence (begin-actions exp) env))
   ((cond? exp) (eval (cond->if exp) env))
   ((and? exp) (eval-and (tests exp) env))
   ((or? exp) (eval-or (tests exp) env))
   ((application? exp)
    (apply (eval (operator exp) env)
	   (list-of-values (operands exp) env)))
   (else (errorf 'EVAL "Unknown Expression Type"))))

;derivated version
(define (and->cond lst)
  (define (rec lst)
    (if (null? lst)
	(list (list 'else 'true))
	(cons (list (list 'not (car lst)) 'false)
	      (rec (cdr lst)))))
  (cons 'cond (rec lst)))
(define (or->cond lst)
  (define (rec lst)
    (if (null? lst)
	(list (list 'else 'false))
	(cons (list (car lst) 'true)
	      (rec (cdr lst)))))
  (cons 'cond (rec lst)))
(define (eval exp env);_eval_
  (cond
   ((self-evaluating? exp) exp)
   ((variable? exp) (lookup-variable-value exp env))
   ((quoted? exp) (text-of-quotation exp))
   ((assigment? exp) (eval-assignment exp env))
   ((definition? exp) (eval-definition exp env))
   ((if? exp) (eval-if exp env))
   ((lambda? exp)
    (make-procedure (lambda-parameters exp)
		    (lambda-body exp)
		    env))
   ((begin? exp)
    (eval-sequence (begin-actions exp) env))
   ((cond? exp) (eval (cond->if exp) env))
   ((and? exp) (eval (and->cond (tests exp)) env))
   ((or? exp) (eval (or->cond (tests exp)) env))
   ((application? exp)
    (apply (eval (operator exp) env)
	   (list-of-values (operands exp) env)))
   (else (errorf 'EVAL "Unknown Expression Type"))))

4.5
(define (arrowed? clause) (eq? '=> (cadr clause)))
(define (arrowed-action clause) (caddr clause))
(define (expand-clauses clauses)
  (if (null? clauses)
      'false
      (let ((first (car clauses))
	    (rest (cdr clauses)))
	(if (cond-else-clause? first)
	    (if (null? rest)
		(sequence->exp (cond-actions first))
		(errorf 'COND->IF "else clause isn`t last"))
	    (if (arrowed? first)
		(make-if (cond-predicate first)
			 (list (arrowed-action first) (cond-predicate first))
			 (expand-clauses rest))
		(make-if (cond-predicate first)
			 (sequence->exp (cond-actions first))
			 (expand-clauses rest)))))))

;test
(cond->if
 '(cond ((assoc 'b '((a 1) (b 2))) => cadr)
	(true 'lol)
	(else false)))

4.6
(define (let? exp) (tagged-list? exp 'let))
(define (make-lambda varlist . expressions)
  (append (list 'lambda varlist)
	  expressions))
(define (let-binds exp) (cadr exp))
(define (let-body-lst exp) (cddr exp))
(define (extract-vars exp) (map car exp))
(define (extract-vals exp) (map cadr exp))
(define (make-let binds . body-lst)
  (cons 
   (apply make-lambda (extract-vars binds) body-lst)
   (extract-vals binds)))
(define (let->combination exp)
  (apply make-let (let-binds exp) (let-body-lst exp)))

;test
(let->combination
 '(let ((a 3) (b 2))
    (yo)
    (hey)))

4.7
(define (let*? exp) (tagged-list? exp 'let*))
(define (let*->nested-lets exp)
  (define (rec binds body-lst)
    (if (null? (cdr  binds))
	(apply make-let (list (car binds)) body-lst)
	(make-let (list (car binds)) (rec (cdr binds) body-lst))))
  (rec (let-binds exp) (let-body-lst exp)))

;test
(eval (let*->nested-lets
       '(let* ((x 3)
	       (y (+ x 2))
	       (z (+ x y 5)))
	  (display "YOY")
	  (* x z))))

4.8
(define (casing-env . exps)
  (list (apply make-lambda '() exps)))
(define (make-definition name exp)
  (list 'define name exp))
(define (named-let? exp) (not (pair? (cadr exp))))
(define (name-of-let exp) (cadr exp))
(define (named-let-binds exp) (caddr exp))
(define (named-let-body-list exp) (cdddr exp))
(define (make-named-let name binds . body-list)
   (casing-env
       (make-definition name
	     (apply make-lambda (extract-vars binds)
		    body-list))
       (cons name (extract-vals binds))))
(define (let->combination exp)
  (if (named-let? exp)
      (apply make-named-let
	     (name-of-let exp)
	     (named-let-binds exp) (named-let-body-list exp))
      (apply make-let (let-binds exp) (let-body-lst exp))))

;test
(eval
 (list 'let (list(list 'n 5))
       (let->combination
	'(let fib-iter ((a 1)
			(b 0)
			(count n))
	   (if (= count 0)
	       b
	       (fib-iter (+ a b) a (- count 1)))))))

4.9
(define (do? env) (tagged-list? env 'do))
(define (do-vars binds) (map car binds))
(define (do-init binds) (map cadr binds))
(define (do-iter binds) (map caddr binds))
(define (make-do binds test . exps)
  (let ((temp-name (gensym)))
    (casing-env
     (make-definition
      temp-name
      (make-lambda
       (do-vars binds)
       (list 'cond
	     test
	     (append '(else)
		   exps
		   (list (cons temp-name (do-iter binds)))))))
     (cons temp-name (do-init binds)))))
(define (do->combination exp)
  (apply make-do (cdr exp)))
(do->combination
 '(do
      ((i 1 (+ i 1))
       (j 1 j))
      ((= i 10) 'done)
    (display i)
    (newline)))

4.12
(define (scan-frame vars vals)
  (cond ((null? vars) #f)
	((eq? var (car vars)) vals)
	(else (scan-frame (cdr vars) (cdr vals)))))
(define (env-loop env)
  (if (eq? env the-empty-environment)
      #f
      (let ((frame (first-frame env)))
	(let ((scanned (scan-frame
			(frame-variables frame)
			(frame-values frame))))
	  (if scanned
	      scanned
	      (env-loop (enclosing-environment env)))))))
(define (lookup-variable-value var env)
  (let ((scan-val (env-loop env)))
    (if scan-val
	(car scan-val)
	(errorf 'lookup-variable-value "Unbound variable : ~s" var))))
(define (set-variable-value! var val env)
  (let ((scan-val (env-loop env)))
    (if scan-val
	(set-car! scan-val val)
	(errorf 'set-variable-value! "Unbound variable ~s" var))))

(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (let ((scan-val (scan-frame
		     (frame-variables frame)
		     (frame-values frame))))
      (if scan-val
	  (set-car! scan-val val)
	  (add-binding-to-frame! var val frame)))))

4.13
;remove first encounter.

(define (scan-frame-full vars vals)
  (cond ((null? vars) #f)
	((eq? var (car vars)) (cons vars vals))
	(else (scan-frame-full (cdr vars) (cdr vals)))))
(define (env-loop-full env)
  (if (eq? env the-empty-environment)
      #f
      (let ((frame (first-frame env)))
	(let ((scanned (scan-frame
			(frame-variables frame)
			(frame-values frame))))
	  (if scanned
	      scanned
	      (env-loop-full (enclosing-environment env)))))))
(define (make-unbound! var env)
  (let ((scanned (env-loop-full env)))
    (if scanned
	(let ((sc-var (car scanned))
	      (sc-val (cdr scanned)))
	  (set-car! sc-var (cadr sc-var))
	  (set-cdr! sc-var (cddr sc-var))
	  (set-car! sc-val (cadr sc-val))
	  (set-cdr! sc-val (cddr sc-val))
	  'removed)
	'already-removed)))


;on evaluator
(define (unbinder? exp)
  (tagged-list? exp 'unbind!))
(define (unbind exp env)
  (let ((removed-var (cadr exp)))
    (make-unbound! var env)))

