1.7

(define (good-enough? guess x)
  (< (abs (- (/ (square guess) x) 1)) 0.0001))
(define (average x y)
  (/ (+ x y) 2))
(define (improve guess x)
  (average guess (/ x guess)))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
(define (my-sqrt x)
  (sqrt-iter x x))

1.8

(define (sq x) (* x x))
(define (tri x) (* x x x))
(define (good-enough? guess x)
  (< (abs (- (/ (tri guess) x) 1)) 0.01))
(define (improve guess x)
  (/ (+ (/ x (sq guess)) (* 2 guess)) 3))
(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))
(define (cube-root x)
  (sqrt-iter x x))


1.11
(define (f n)
  (define (iter x1 x2 x3 count)
    (if (= count 0) x1
        (iter x2 x3 (+ x3 (* 2 x2) (* 3 x1)) (- count 1)))
    )
  (if (< n 3) n (iter 0 1 2 n)))


1.12
(define (pascal row col)
  (cond ((or (= col 0) (= col row)) 1)
        ((or (< col 0) (> col row)) 0)
        (else (+ (pascal (- row 1) col) (pascal (- row 1) (- col 1))))))

1.16
(define (fast-expt b n)
  (cond
   ((= n 0) 1)
   ((even? n) (fast-expt (* b b) (/ n 2)))
   (else (* b (fast-expt (* b b) (/ (- n 1) 2))))))

1.17

(define (mul a b)
  (define (double x) (* x 2))
  (define (halve x) (/ x 2))
  (cond
   ((= b 0) 0)
   ((even? b) (mul (double a) (halve b)))
   (else (+ a (mul a (- b 1))))))

1.18

(define (mul a b)
  (define (double x) (* x 2))
  (define (halve x) (/ x 2))
  (define (iter a b cur)
    (cond 
     ((= b 0) cur)
     ((even? b) (iter (double a) (halve b) cur))
     (else (iter a (- b 1) (+ cur a)))))
  (iter a b 0))

1.29
(define (simpson f a b n)
  (define (fromto a b step)
    (if (< b a) 0 (+ (f a) (fromto (+ a step) b step))))
  (let ((step (/ (- b a) n)))
    (* (/ step 3) 
       (+ (f a) 
          (f b) 
          (* 4 (fromto (+ a step) (- b step) (* 2 step))) 
          (* 2 (fromto (+ a (* 2 step)) (- b (* 2 step)) (* 2 step)))))))

1.30
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ (term a) result))))
  (iter a 0))

1.31
(define (product term a next b)
  (define (iter a result)
    (if (< b a)
        result
        (iter (next a) (* (term a) result))))
  (iter a 1))

1.32
;-iter
(define (accumulate combiner null-value term a next b)
  (define (iter a result)
    (if (< b a)
        result
        (iter (next a) (combiner (term a) result))))
  (iter a null-value))
;-recur
(define (accumulate combiner null-value term a next b)
  (define (rec a)
    (if (< b a)
        null-value
        (combiner (term a) (rec (next a)))))
  (rec a))

<여기 푼게 있어야 - 분수 arithmetic>

2.17
(define (last-pair l)
  (if (null? (cdr l)) l (last-pair (cdr l))))
(last-pair (list 23 72 149 34))

2.18
(define (reverse l)
  (define (iter old new)
    (if (null? old)
        new
        (iter (cdr old) (cons (car old) new))))
  (iter l '()))

2.19
(define no-more? null?)
(define except-first-denomination cdr)
(define first-denomination car)

2.20
(define (same-parity x . y)
  (define (rec par l)
    (cond ((null? l) '())
          ((eq? (even? (car l)) par)
           (cons (car l) (rec par (cdr l))))
          (else (rec par (cdr l)))
        ))
  (rec (even? x) (cons x y)))

2.21
(define (square-list items)
  (define (sq x) (* x x))
  (if (null? items)
      '()
      (cons (sq (car items)) (square-list (cdr items)))))

(define (square-list-map items)
  (map (lambda (x) (* x x)) items))


2.23
(define (for-each proc lst)
  (if (null? lst)
      '()
      (begin
        (proc (car lst))
        (for-each proc (cdr lst)))))

2.27
(define (deep-reverse lst)
  (define (iter old new)
    (cond ((null? old) new)
          ((pair? (car old)) (iter (cdr old) (cons (deep-reverse (car old)) new)))
          (else (iter (cdr old) (cons (car old) new)))))
  (iter lst '()))

2.28
(define (fringe lst)
  (define (rec lst next)
    (cond ((null? lst) next)
          ((pair? lst) (rec (car lst) (rec (cdr lst) next)))
          (else (cons lst next))))
  (rec lst '()))

2.29
(define (left-branch mobile)
  (car mobile))
(define (right-branch mobile)
  (cadr mobile))
(define (branch-length branch)
  (car branch))
(define (branch-structure branch)
  (cadr branch))
(define (mobile-or-weight object)
  (if (pair? object)
      (total-weight object)
      object))
(define (branch-weight branch)
  (mobile-or-weight (branch-structure branch)))
(define (total-weight mobile)
  (if (pair? mobile)
      (+ (branch-weight (left-branch mobile))
        (branch-weight (right-branch mobile)))
      mobile))
(define (balanced? mobile)
  (define (left-struct mobile)
    (branch-structure (left-branch mobile)))
  (define (right-struct mobile)
    (branch-structure (right-branch mobile)))
  (define (torque branch)
    (* (total-weight (branch-structure branch)) (branch-length branch)))
  (if (pair? mobile)
      (and (= (torque (left-branch mobile))
          (torque (right-branch mobile)))
           (balanced? (left-struct mobile))
           (balanced? (right-struct mobile)))
      #t ))

2.30
(define (square x) (* x x))
(define (square-tree tree)
  (cond ((null? tree) tree)
         ((pair? tree) (cons (square-tree (car tree))
                                 (square-tree (cdr tree))))
         (else (square tree))))
(define (square-tree-map tree)
  (if (pair? tree)
      (map square-tree-map tree)
      (square tree)))

2.31
(define (square-tree tree) (tree-map square tree))
(define (tree-map f tree)
  (cond ((null? tree) tree)
        ((pair? tree) (cons (tree-map f (car tree))
                            (tree-map f (cdr tree))))
        (else (f tree))))

2.32
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (x) (cons (car s) x)) rest)))))

2.33
(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) nil sequence))
(define (append seq1 seq2)
  (accumulate cons seq2 seq1))
(define (length sequence)
  (accumulate (lambda (x y) (+ y 1)) 0 sequence))
(define (length sequence)
  (accumulate (lambda (x y) (+ y 1)) 0 sequence))

2.34
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
              0
              coefficient-sequence))

2.35
(define (count-leaves t)
  (accumulate + 0 (map (lambda (x) 1) t)))

2.36
(define (accumulate-n op init seqs)
  (define (cars lis)
    (if (null? lis)
	'()
	(cons (caar lis) (cars (cdr lis)))))
  (define (cdrs lis)
    (if (null? lis)
	'()
	(cons (cdar lis) (cdrs (cdr lis)))))
  (if (null? (car seqs))
      '()
      (cons (accumulate op init (cars seqs))
            (accumulate-n op init (cdrs seqs)))))
